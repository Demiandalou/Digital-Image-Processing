from cv2 import cv2
import numpy as np
import matplotlib.pyplot as plt
import random

def edge_detect(I,ksize):
    Icp = cv2.cvtColor(I, cv2.COLOR_BGR2GRAY)
    Icpa = cv2.Sobel(Icp, cv2.CV_16S, 1, 0, ksize=ksize)
    Icpb = cv2.Sobel(Icp, cv2.CV_16S, 0, 1, ksize=ksize)
    lapa = cv2.Sobel(Icpa, cv2.CV_16S, 1, 0, ksize=ksize)
    lapb = cv2.Sobel(Icpb, cv2.CV_16S, 1, 0, ksize=ksize)
    return Icpa.astype(np.float),Icpb.astype(np.float),lapa.astype(np.float),lapb.astype(np.float)

def priority_of_bound(I, mask, bound,cnt):
    if cnt==0:
        plt.imshow(cv2.cvtColor(bound, cv2.COLOR_BGR2RGB))
        plt.title('find boundary')
        plt.show()
    pos = np.where(bound == 255)
    boundPoint=[]
    for i in range(len(pos[0])):
        tmp=(pos[0][i], pos[1][i])
        boundPoint.append(tmp)
    
    # use Sobel operator to do edge detection
    Icpa,Icpb,lapa,lapb=edge_detect(I,3)
    maxPri = 0
    priority = {}
    # Select patch around pixel p with highest priority Psi(p)
    for p in boundPoint:
        block=mask[p[0]-7:p[0]+8,p[1]-7:p[1]+8]
        normsum=np.sum(block.astype(np.float)/255)
        cur=1-normsum/225
        prod=Icpa[p]*lapb[p]+(-Icpb[p])*lapa[p]
        if prod>=0:
            coef=prod
        else:
            coef = Icpb[p]*lapa[p] + (-Icpa[p])*lapb[p]
        curPri = np.sqrt(Icpa[p]**2 + Icpb[p]**2) * coef
        if curPri > maxPri:
            maxPri = curPri
        priority[p] = cur*np.log(curPri)
        
        if cnt==0: 
            priority[p] = cur*curPri
    if cnt==0:
        showBound= bound.copy()
        for k in priority:
            showBound[k] = 1000*priority[k]/maxPri
        plt.imshow(showBound, cmap='gray')
        plt.title('calculate priority')
        plt.show()
    return priority

# Visulize  patch A: patch with patial mask to be replaced later
#           patch B: the most similar patch to A
#           patch C: the new patch generated by fusing B with A
def visulize_patches(I,curPos,patch_size,cover):
    simblock=I[curPos[0]:curPos[0]+patch_size, curPos[1]:curPos[1]+patch_size, :]
    plt.imshow(cv2.cvtColor(simblock,cv2.COLOR_BGR2RGB))
    plt.title('patch A')
    plt.show()
    plt.imshow(cv2.cvtColor(cover, cv2.COLOR_BGR2RGB))
    plt.title('patch B')
    plt.show()
    #replace pixel
    tmp = np.zeros((patch_size, patch_size, 3), dtype=np.uint8)
    for i in range(patch_size):
        for j in range(patch_size):
            if (I[curPos[0]+i, curPos[1]+j] == [0, 0, 0]).all():
                tmp[i, j] = cover[i, j]
            else:
                tmp[i, j] = I[curPos[0]+i, curPos[1]+j]
    plt.imshow(cv2.cvtColor(tmp, cv2.COLOR_BGR2RGB))
    plt.title('patch C')
    plt.show()
    
def img_inpainting(I,mask,patch_size):
    cnt=0
    while np.sum(mask) != 0:
        # Step1 find bound
        mask_cp = mask.copy()
        tmp = cv2.Laplacian(mask_cp, cv2.CV_16SC3, ksize=3)
        contour = cv2.convertScaleAbs(tmp)
        # The first return value is the value that was used for the thresholding
        bound=cv2.threshold(contour, 150, 255, cv2.THRESH_BINARY)[1]

        # Step2 calculate the priority of the boundary point
        priority=priority_of_bound(I,mask,bound,cnt)
        step=10
        val=0
        pos=None

        # Step3 Searching the full image, and use other patch to replace masked part in cur patch
        for k in priority:
            if priority[k] >= val:
                val = priority[k]
                pos = k
        curPos = (pos[0] - patch_size//2, pos[1] - patch_size//2)
        block=I[curPos[0]:curPos[0]+patch_size, curPos[1]:curPos[1]+patch_size, :]
        block=block.astype(np.float)
        mostSimilar=float('inf')

        # Find the most similar patch
        for i in range(0, len(I), step):
            for j in range(0, len(I[0]), step):
                patch = I[i:i+patch_size, j:j+patch_size]
                if len(patch) != patch_size or len(patch[0]) != patch_size:
                    continue
                if np.sum(mask[i:i+patch_size, j:j+patch_size]) != 0:
                    similar=float('inf')
                else: 
                    diff=np.abs(patch.astype(np.float) - block)
                    similar=np.sum(diff)
                if similar<mostSimilar:
                    mostSimilar=similar
                    simPatch=(i,j)
        
        # replace mask area using the most similar patch
        fuse = I[simPatch[0]:simPatch[0]+patch_size, simPatch[1]:simPatch[1]+patch_size]
        if cnt==0:
            visulize_patches(I,curPos,patch_size,fuse)
        I[curPos[0]:curPos[0]+patch_size, curPos[1]:curPos[1]+patch_size, :] = fuse
        if cnt==0:
            plt.imshow(cv2.cvtColor(I, cv2.COLOR_BGR2RGB))
            plt.title('one step patching')
            plt.show()
        mask[curPos[0]:curPos[0]+patch_size, curPos[1]:curPos[1]+patch_size] = 0
        cnt+=1
    


